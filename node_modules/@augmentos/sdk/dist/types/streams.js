"use strict";
// src/streams.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.STREAM_CATEGORIES = exports.StreamCategory = exports.StreamType = void 0;
exports.isStreamCategory = isStreamCategory;
exports.getStreamTypesByCategory = getStreamTypesByCategory;
/**
 * Types of streams that TPAs can subscribe to
 *
 * These are events and data that TPAs can receive from the cloud.
 * Not all message types can be subscribed to as streams.
 */
var StreamType;
(function (StreamType) {
    // Hardware streams
    StreamType["BUTTON_PRESS"] = "button_press";
    StreamType["HEAD_POSITION"] = "head_position";
    StreamType["GLASSES_BATTERY_UPDATE"] = "glasses_battery_update";
    StreamType["PHONE_BATTERY_UPDATE"] = "phone_battery_update";
    StreamType["GLASSES_CONNECTION_STATE"] = "glasses_connection_state";
    StreamType["LOCATION_UPDATE"] = "location_update";
    // Audio streams
    StreamType["TRANSCRIPTION"] = "transcription";
    StreamType["TRANSLATION"] = "translation";
    StreamType["VAD"] = "VAD";
    StreamType["AUDIO_CHUNK"] = "audio_chunk";
    // Phone streams
    StreamType["PHONE_NOTIFICATION"] = "phone_notification";
    StreamType["NOTIFICATION_DISMISSED"] = "notification_dismissed";
    // System streams
    StreamType["START_APP"] = "start_app";
    StreamType["STOP_APP"] = "stop_app";
    StreamType["OPEN_DASHBOARD"] = "open_dashboard";
    // Video streams
    StreamType["VIDEO"] = "video";
    // Special subscription types
    StreamType["ALL"] = "all";
    StreamType["WILDCARD"] = "*";
})(StreamType || (exports.StreamType = StreamType = {}));
/**
 * Categories of stream data
 */
var StreamCategory;
(function (StreamCategory) {
    /** Data from hardware sensors */
    StreamCategory["HARDWARE"] = "hardware";
    /** Audio processing results */
    StreamCategory["AUDIO"] = "audio";
    /** Phone-related events */
    StreamCategory["PHONE"] = "phone";
    /** System-level events */
    StreamCategory["SYSTEM"] = "system";
})(StreamCategory || (exports.StreamCategory = StreamCategory = {}));
/**
 * Map of stream categories for each stream type
 */
exports.STREAM_CATEGORIES = {
    [StreamType.BUTTON_PRESS]: StreamCategory.HARDWARE,
    [StreamType.HEAD_POSITION]: StreamCategory.HARDWARE,
    [StreamType.GLASSES_BATTERY_UPDATE]: StreamCategory.HARDWARE,
    [StreamType.PHONE_BATTERY_UPDATE]: StreamCategory.HARDWARE,
    [StreamType.GLASSES_CONNECTION_STATE]: StreamCategory.HARDWARE,
    [StreamType.LOCATION_UPDATE]: StreamCategory.HARDWARE,
    [StreamType.TRANSCRIPTION]: StreamCategory.AUDIO,
    [StreamType.TRANSLATION]: StreamCategory.AUDIO,
    [StreamType.VAD]: StreamCategory.AUDIO,
    [StreamType.AUDIO_CHUNK]: StreamCategory.AUDIO,
    [StreamType.PHONE_NOTIFICATION]: StreamCategory.PHONE,
    [StreamType.NOTIFICATION_DISMISSED]: StreamCategory.PHONE,
    [StreamType.START_APP]: StreamCategory.SYSTEM,
    [StreamType.STOP_APP]: StreamCategory.SYSTEM,
    [StreamType.OPEN_DASHBOARD]: StreamCategory.SYSTEM,
    [StreamType.VIDEO]: StreamCategory.HARDWARE,
    [StreamType.ALL]: StreamCategory.SYSTEM,
    [StreamType.WILDCARD]: StreamCategory.SYSTEM
};
/**
 * Helper function to check if a stream type is of a particular category
 */
function isStreamCategory(streamType, category) {
    return exports.STREAM_CATEGORIES[streamType] === category;
}
/**
 * Helper function to get all stream types in a category
 */
function getStreamTypesByCategory(category) {
    return Object.entries(exports.STREAM_CATEGORIES)
        .filter(([_, cat]) => cat === category)
        .map(([type]) => type);
}
